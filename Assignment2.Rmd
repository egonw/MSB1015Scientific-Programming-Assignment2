---
title: "Assignment2"
author: "Raphael Stolpe"
date: "9/23/2019"
output: html_document
---

```{r setup, include=FALSE}
library(XML)
library(rcdk)
#library(rJava)
#install.packages("WikidataQueryServiceR")
library(WikidataQueryServiceR)
library(Metrics)
```

```{r query}


#Alkanes
query <- 'SELECT ?comp ?compLabel ?bp ?bpUnit ?bpUnitLabel ?CC WHERE {   ?comp wdt:P31/wdt:P279* wd:Q41581 ;   wdt:P233 ?CC ;     p:P2102 [         ps:P2102 ?bp ;           psv:P2102/wikibase:quantityUnit  ?bpUnit         ] .   SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". } } '
unitquery <- '
      SELECT DISTINCT ?alkane ?alkaneLabel ?boilingpoint ?unit ?unitLabel ?smiles WHERE {
          ?alkane (wdt:P31|wdt:P279) wd:Q11173;
            rdfs:label ?alkaneLabel;
            wdt:P2102 ?boilingpoint;
            wdt:P233 ?smiles;
  OPTIONAL {
   # unit 
    ?alkane p:P2102/psv:P2102 [  wikibase:quantityUnit       ?unit ].}
          FILTER(STRENDS(?alkaneLabel, "ane"))
          FILTER((LANG(?alkaneLabel)) = "en")
          SERVICE
        }'
r <- query_wikidata(query)
labels <- c("C", "F", "K")
units.factor <- factor(r$unit, levels = labels)




```

```{r}

smiles <- r$CC
parsed_smiles <- parse.smiles(smiles, kekulise=TRUE)

descNames <- c(
'org.openscience.cdk.qsar.descriptors.molecular.KierHallSmartsDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.APolDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.HBondDonorCountDescriptor'
)

descs <- eval.desc(parsed_smiles, descNames)

# control for boilingpoint units: convert all to kelvin
r$bp[r$bpUnitLabel == "degree Celsius"] <- r$bp[r$bpUnitLabel == "degree Celsius"] + 273.15
r$bpUnitLabel[r$bpUnitLabel == "degree Celsius"] <- "kelvin"
r$bp[r$bpUnitLabel == "degree Fahrenheit"] <- (r$bp[r$bpUnitLabel == "degree Fahrenheit"]-32)*5/9 + 273.15
r$bpUnitLabel[r$bpUnitLabel == "degree Fahrenheit"] <- "kelvin"



```

```{r}
library(pls)
library(e1071)
library(randomForest)

data <- data.frame(r$bp, descs)
set.seed(42)
rows <- sample(nrow(data))
data <- data[rows, ]
split <- round(nrow(data)*0.8)

train <- data[1:split, ]
test <- data[(split+1):nrow(data), ]
ytrain <- train$r.bp
ytest <- test$r.bp

# Train pls regression model
mdl <- plsr(train$r.bp ~ (apol + khs.ssCH2 + khs.sCH3 + khs.sssCH + nHBDon), data = train, ncomp = 5, validation = "LOO")
mdl <- plsr(train$r.bp ~., data = train, validation = "LOO")
error <- RMSEP(mdl)
predicted <- predict(mdl, test)
error <- rmse(predicted, ytest)
error <- vector()
for (i in 1:81) {
  
  error[i] <- rmse(predicted[, ,i], ytest)
}

error

svm <- svm(r.bp ~ (apol + khs.ssCH2 + khs.sCH3 + khs.sssCH), data = train)
svm.pred <- predict(svm, test)
errror.svm <- rmse(svm.pred, ytest)
```
## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
